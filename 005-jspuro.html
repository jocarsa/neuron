<!doctype>
<html> 
  <head>
  </head>
  <body>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <canvas id="canvas"></canvas>
    <script>
   // HTML & JS project to simulate projectile shooting with simple iterative improvement

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;

// Launcher position (bottom left)
const launcher = { x: 50, y: canvas.height - 50 };
// Target position (bottom right)
const target = { x: 700, y: canvas.height - 50 };

// Gravity
const g = 9.81;

// Draw launcher
function drawLauncher() {
  ctx.fillStyle = 'green';
  ctx.fillRect(launcher.x - 10, launcher.y - 10, 20, 20);
}

// Draw target
function drawTarget() {
  ctx.beginPath();
  ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);
  ctx.fillStyle = 'red';
  ctx.fill();
  ctx.closePath();
}

// Function to simulate a projectile given angle and velocity
function simulateProjectile(angle, velocity) {
  const radians = (angle * Math.PI) / 180;
  const timeStep = 0.05;
  let t = 0;
  let x = launcher.x;
  let y = launcher.y;

  let projectilePath = [];

  while (y <= canvas.height && x < canvas.width && y >= 0) {
    x = launcher.x + velocity * Math.cos(radians) * t;
    y = launcher.y - (velocity * Math.sin(radians) * t - 0.5 * g * t * t);
    projectilePath.push({ x, y });
    t += timeStep;
  }

  return projectilePath;
}

// Animated projectile launch
let currentPath = [];
let currentIndex = 0;
let trailPoints = [];
let lastAngle = Math.random() * 60 + 15;
let lastVelocity = Math.random() * 50 + 50;

function launchProjectile(angle, velocity) {
  currentPath = simulateProjectile(angle, velocity);
  currentIndex = 0;
  trailPoints = [];
}

function drawAnimatedProjectile() {
  if (currentPath.length === 0 || currentIndex >= currentPath.length) return;
  const point = currentPath[currentIndex];
  trailPoints.push(point);
  ctx.beginPath();
  ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = 'blue';
  ctx.fill();
  ctx.closePath();
  currentIndex++;
}

function drawTrail() {
  if (trailPoints.length === 0) return;
  ctx.beginPath();
  ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
  for (let i = 1; i < trailPoints.length; i++) {
    ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
  }
  ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
  ctx.stroke();
  ctx.closePath();
}

// Main loop
function mainLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawLauncher();
  drawTarget();
  drawTrail();
  drawAnimatedProjectile();

  if (currentIndex >= currentPath.length && currentPath.length > 0) {
    const lastPoint = currentPath[currentPath.length - 1];
    if (Math.abs(lastPoint.x - target.x) > 10 || Math.abs(lastPoint.y - target.y) > 10) {
      // Adjust angle and velocity if the projectile missed the target
      lastAngle += (Math.random() - 0.5) * 5; // Small random adjustment to angle
      lastVelocity += (Math.random() - 0.5) * 5; // Small random adjustment to velocity
      launchProjectile(lastAngle, lastVelocity);
    }
  }

  requestAnimationFrame(mainLoop);
}

// Launch a projectile with initial random angle and velocity
launchProjectile(lastAngle, lastVelocity);
mainLoop();


    </script>
  </body>
</html>
